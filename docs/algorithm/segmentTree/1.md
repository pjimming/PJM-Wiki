#### 线段树

- 线段树的每个节点都代表一个 **区间**。
- 线段树具有唯一的根结点，代表的区间是整个统计范围，如 $[1,N]$。
- 线段树的每个叶结点都代表一个长度为 $1$ 的元区间 $[x,x]$。
- 对于每个内部结点 $[l,r]$，他的左子结点是 $[l,mid]$，右子结点是 $[mid+1,r]$，其中$mid=⌊\frac{l + r}{2}⌋$。

#### 线段树Tip
1. 线段树是一棵非常漂亮二叉树，（除了最后一层外，是一棵满二叉树），因此我们采用堆的思想来存整棵树
    - 编号 x 的父节点：$⌊\frac{x}{2}⌋$ ，常书写的代码：`x >> 1`
    - 编号 x 的左儿子：$2x$ ，常书写的代码：`x << 1`
    - 编号 x 的右儿子：$2x+1$ ，常书写的代码：`x << 1 | 1`
2. 线段树的下一层都是把当前层进行平分 $mid=⌊\frac{l + r}{2}⌋$
    - 左区间为 $[l,mid]$
    - 右区间为 $[mid+1,r]$

    **注意，线段树的两个子区间是不允许相交的**

    **这也决定了许多题的分块要进行额外的操作，使之区间不能相交**

3. 线段树一般开长度为 $4N$ 的空间
    - 一个长度为 $N$ 的区间，最终的叶结点，为 $N$ 个
    - 先考虑**理想状态**下（包含最后一层，整个二叉树都是满二叉树），$N$ 个叶结点的满二叉树有 $N+\frac{N}{2}+\frac{N}4+⋅⋅⋅+2+1=2N−1$ 个结点。
    - 但是线段树的存储方式下，最后一层还会有盈余，**最坏情况下**，最后一层是倒数第二层（也就是满二叉树的倒数第一层）两倍的点，所以所以保存线段树的数组长度要不小于 $4N$ 才能保证不会越界

#### 线段树的模版
`pushup()`：由子结点的信息来计算父结点的信息

`build()`：将一段区间初始化为线段树

`modify()`：修改

- 单点修改（easy）

- 区间修改（hard）：用到`pushdown`操作，懒标记思想

`query()`：区间询问（例如：查询 $[a,b]$ 区间）$O(log⁡n)$ 最多是 $4log⁡n$ 的时间，因为最坏有两条链

1. $[l,r]⊃[T_l,T_r]$，直接返回

2. $[l,r]∩[T_l,T_r]≠∅$，递归下去

    - $l≤T_l≤r≤T_r$：

        1. $r≤T_{mid}$：只递归左半边

        - $T_{mid}<r$：递归左半边 + 递归右半边（但右子树完全包含，只递归一层就返回了）

    - $T_l≤l≤T_r≤r$：
        1. $l≥T_{mid}$：只递归右半边

        - $T_{mid}>l$：递归右半边 + 递归左半边（但左子树完全包含，只递归一层就返回了）

    - $T_l≤l≤r≤T_r$：

        1. $r≤T_{mid}$：只递归左半边

        - $T_{mid}<l$：只递归右半边

        - $l≤T_{mid}<r$：递归左半边 + 递归右半边

3. $[l,r]∩[T_l,T_r]=∅$，不存在这种可能，因为初始区间包含了合法的所有范围。

