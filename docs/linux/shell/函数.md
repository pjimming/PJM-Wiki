`bash`中的函数类似于`C/C++`中的函数，但`return`的返回值与`C/C++`不同，返回的是`exit code`，取值为0-255，0表示正常结束。

如果想获取函数的输出结果，可以通过`echo`输出到`stdout`中，然后通过`$(function_name)`来获取`stdout`中的结果。

函数的`return`值可以通过`$?`来获取。

命令格式：
```sh
[function] func_name() {  # function关键字可以省略
    语句1
    语句2
    ...
}
```

---

#### 不获取 `return`值和`stdout`值
示例
```sh
func() {
    name=pjm
    echo "Hello $name"
}

func
```

输出结果：
```sh
Hello pjm
```

---

#### 获取 `return`值和`stdout`值
不写`return`时，默认`return 0`。

示例
```sh
func() {
    name=pjm
    echo "Hello $name"

    return 123
}

output=$(func)
ret=$?

echo "output = $output"
echo "return = $ret"
```

输出结果：
```sh
output = Hello pjm
return = 123
```

---

#### 函数的输入参数
在函数内，`$1`表示第一个输入参数，`$2`表示第二个输入参数，依此类推。

注意：函数内的`$0`仍然是文件名，而不是函数名。

示例：
```sh
func() {  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0
    word=""
    while [ "${word}" != 'y' ] && [ "${word}" != 'n' ]
    do
        read -p "要进入func($1)函数吗？请输入y/n：" word
    done

    if [ "$word" == 'n' ]
    then
        echo 0
        return 0
    fi  

    if [ $1 -le 0 ] 
    then
        echo 0
        return 0
    fi  

    sum=$(func $(expr $1 - 1))
    echo $(expr $sum + $1)
}

echo $(func 10)
```

输出结果：
```
55
```

---

#### 函数内的局部变量
可以在函数内定义局部变量，作用范围仅在当前函数内。

可以在递归函数中定义局部变量。

命令格式：
```sh
local 变量名=变量值
```

例如：
```sh
#! /bin/bash

func() {
    local name=pjm
    echo $name
}
func

echo $name
```

输出结果：
```sh
pjm
# 此处为空行 第九行的echo没有输出$name的内容
```

第一行为函数内的`name`变量，第二行为函数外调用`name`变量，会发现此时该变量不存在。
